<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>üè∞ Castle Conquerors</title>
    <link rel="stylesheet" href="../static/styles/mapExample.css">
    <link rel="stylesheet" th:href="@{~/styles/mapExample.css}">
</head>
<body>

<!--Clouds-->
<div class="clouds">
    <div class="cloud"></div>
    <div class="cloud"></div>
    <div class="cloud"></div>
    <div class="cloud"></div>
    <div class="cloud"></div>
    <div class="cloud"></div>
    <div class="cloud"></div>
    <div class="cloud"></div>
    <div class="cloud"></div>
    <div class="cloud"></div>
    <div class="cloud"></div>
</div>


<!--The leaveGameButton and Game ID with the copy button-->
<!--are both wrapped in a container to be at the bottom right of the screen-->
<div class="bottom-right-container">
    <div class="copy-container">
        <span th:text="'Game ID: ' + ${gameID}">default game ID</span>
        <button id="copyButton"></button>
    </div>
    <button id="leaveGameButton">Leave the game</button>
</div>


<!--Player's info box and game state-->
<div class="player-info">
    <div class="player-box">
        <span class="username-icon"><img src="../images/myPlayer.png" alt="Player Icon"></span>
        <h2 th:text="${playerState.getPlayerUsername()}"></h2>
    </div>
    <div id="playerStateDiv">
        <p id="playerTreasureCollected" style="display: none;">You have collected the treasure! üíé</p>
        <p id="playerTreasureNotCollected">You haven't collected the treasure yet.</p>
    </div>
</div>

<!--Game title-->
<h1 id="gameTitle">Castle Conquerors</h1>

<!--Opponent's info box and game state-->
<div class="opponent-info">
    <div class="opponent-box">
        <h2 id="opponentUsername" style="display: none;"></h2>
        <span class="opponent-icon"><img src="../images/enemyPlayer.png" alt="Player Icon"></span>
    </div>
    <div id="opponentStateDiv">
        <p id="opponentTreasureCollected" style="display: none;">Enemy has collected the treasure üíÄ</p>
        <p id="opponentTreasureNotCollected">Enemy hasn't found the treasure.</p>
    </div>
</div>


<!--Game container (state messages, and the tabla/map itself)-->
<div class="game-container">
    <div class="state-messages">
        <p id="stateWon">Congratulations, you won!</p>
        <p id="stateLost">Sorry, you lost. Better luck next time!</p>
        <p id="stateMustAct">It's your turn to act.</p>
        <p id="stateMustWait">Please wait for your opponent.</p>
    </div>

<!--End game container!-->
    <div id="endGameContainer">
        <div class="shadowBox">
            <h1 id="endGameMessage"></h1>
            <!--Game error message-->
            <div id="errorMessage">Sample error message</div>
            <div id="return">Press anywhere to return to menu</div>
        </div>
    </div>



 <!--Moved the table styling into mapExample.css-->
    <div class="table-container">
        <table>
            <tr th:each="mapRow : ${map}">
                <td th:each="tile : ${mapRow}"
                    th:id="${tile.getTerrain().toString()}">
                    <div th:if="${tile.getPlayerPositionState() == T(messagesbase.messagesfromserver.EPlayerPositionState).MyPlayerPosition}">ü•∑</div>
                    <div th:if="${tile.getPlayerPositionState() == T(messagesbase.messagesfromserver.EPlayerPositionState).EnemyPlayerPosition}">üë§</div>
                    <div th:if="${tile.getPlayerPositionState() == T(messagesbase.messagesfromserver.EPlayerPositionState).BothPlayerPosition}">üë•</div>
                    <div th:if="${tile.getFortState() == T(messagesbase.messagesfromserver.EFortState).MyFortPresent}">üè∞</div>
                    <div th:if="${tile.getFortState() == T(messagesbase.messagesfromserver.EFortState).EnemyFortPresent}">‚õ´</div>
                    <div th:if="${tile.getTreasureState() == T(messagesbase.messagesfromserver.ETreasureState).MyTreasureIsPresent}">üí∞</div>
                </td>
            </tr>
        </table>
    </div>
</div>

<!--Notification after copying the Game ID-->
<div id="notification" style="display: none;">Game ID copied to clipboard!</div>

<!--Leave the game button with its pop-ups-->
<div id="leaveGamePopup" style="display: none;">
    <h1>Are you sure you want to go back to the menu?</h1>
    <h2>This will automatically count as a loss!</h2>
    <button id="confirmLeave">Yes</button>
    <button id="cancelLeave">No</button>
</div>


<!--Control buttons-->
<div id="buttonDiv">
    <button id="upButton" data-move="Up"></button>

    <div class="directional-buttons">
        <button id="leftButton" data-move="Left"></button>
        <button id="downButton" data-move="Down"></button>
        <button id="rightButton" data-move="Right"></button>
    </div>
</div>



<script>
	const gameID = "[[${gameID}]]";

    let playerTreasureFound = false;
	let opponentTreasureFound = false;
	
	function addRedLine() {
	    const rows = document.querySelectorAll('table tr');
	    if (!rows.length) {
	        console.log("No rows found.");
	        return;
	    }
	
	    const columns = rows[0].querySelectorAll('td').length;
	
	    if (rows.length >= columns) {
	        const middleRowIndex = Math.floor(rows.length / 2);
	        rows[middleRowIndex].classList.add('red-line');
	    } else {
	        console.log("Adding vertical red line.");
	        rows.forEach(row => {
	            const cells = row.querySelectorAll('td');
	            const middleColumnIndex = Math.floor(columns / 2);
	            cells[middleColumnIndex].classList.add('red-line');
	        });
	    }
	}

	let playerCanMakeMove = false;
	let playerTreasureRevealed = false;
	let playerTreasureCollected = false;
	let playerHasAlreadyVisitedTreasure = false;
	let playerEnemyFortRevealed = false;

    function updateGameData() {	    
	    if (!gameID) {
	        console.error("Game ID not found");
	        return;
	    }
	    
	    // Fetch player data
	    fetch(`/game/${gameID}/playerdata`).then(response => {
			return response.json();
	    }).then(data => {
			if (data.revealedTreasure) {
	            playerTreasureRevealed = true;
	        }
	        
	        if (data.collectedTreasure) {
	            playerTreasureCollected = true;
	        }
	        
	        if (data.revealedEnemyFort) {
	            playerEnemyFortRevealed = true;
	        }

			if(!playerTreasureFound){
				if (data && data.collectedTreasure) {
					document.getElementById('playerTreasureCollected').style.display = 'block';
					document.getElementById('playerTreasureNotCollected').style.display = 'none';

					playerTreasureFound = true;
				}
			}
		    
			const states = ['stateMustAct', 'stateMustWait', 'stateWon', 'stateLost'];
		    states.forEach(stateID => {
		        if (stateID === `state${data.state}`) {
		            document.getElementById(stateID).style.display = 'block';
		        } else {
		            document.getElementById(stateID).style.display = 'none';
		        }
		    });

			// Check if can make to alter buttons
			if("MustAct" == data.state){
				document.getElementById("buttonDiv").style.display = 'flex'
				playerCanMakeMove = true;
			} else {
				document.getElementById("buttonDiv").style.display = 'none'
				playerCanMakeMove = false
			}

	    }).catch(error => {
	        console.error('Player fetch Error:', error);
	    });
	
	    // Fetch map data
	    fetch(`/game/${gameID}/mapdata`).then(response => {
	        return response.json();
	    }).then(data => {
	        const mapTable = document.querySelector('table');
	        // Clear existing map
	        while (mapTable.firstChild) {
	            mapTable.removeChild(mapTable.firstChild);
	        }
	        data.forEach(row => {
		    const tr = document.createElement('tr');
		    row.forEach(tile => {
		        const td = document.createElement('td');
				td.id = tile.terrain;
				
				const playerImg = document.createElement('img');
				playerImg.classList.add('player-icon');
				if (tile.playerPositionState === "MyPlayerPosition") {
				    playerImg.src = '../images/myPlayer.png';
				    td.appendChild(playerImg);
				} else if (tile.playerPositionState === "EnemyPlayerPosition") {
				    playerImg.src = '../images/enemyPlayer.png';
				    td.appendChild(playerImg);
				} else if (tile.playerPositionState === "BothPlayerPosition") {
		            playerImg.src = '../images/bothPlayers.png';
				    td.appendChild(playerImg);
		        }
		
		        if (tile.fortState === "MyFortPresent") {
					if (tile.playerPositionState === "MyPlayerPosition") {
						playerImg.src = '../images/myFortAndMyPlayer.png';
				    	td.appendChild(playerImg);
					} else if (tile.playerPositionState === "EnemyPlayerPosition") {
						playerImg.src = '../images/enemyCapturedMyFort.png';
				    	td.appendChild(playerImg);
					} else { // Both players need to be handled
						playerImg.src = '../images/myFort.png';
				    	td.appendChild(playerImg);
					}
		        } else if (tile.fortState === "EnemyFortPresent") {
					if (tile.playerPositionState === "MyPlayerPosition") {
						playerImg.src = '../images/enemyFortCapturedByMe.png';
				    	td.appendChild(playerImg);
					} else if (playerEnemyFortRevealed) {
						playerImg.src = '../images/enemyFort.png';
				    	td.appendChild(playerImg);
					}
		        }
		
		        if (tile.treasureState === "MyTreasureIsPresent") {
					if (tile.playerPositionState === "NoPlayerPresent") {
						if (!playerTreasureCollected) {
							playerImg.src = '../images/treasureRevealed.png';
				    		td.appendChild(playerImg);
						} else {
							playerImg.src = '../images/treasureCollected.png';
				    		td.appendChild(playerImg);
				    		playerHasAlreadyVisitedTreasure = true;			
				    	}
					} else if (tile.playerPositionState === "MyPlayerPosition") {
						if (!playerHasAlreadyVisitedTreasure) {
							playerImg.src = '../images/treasureFound.png';
				    		td.appendChild(playerImg);
						} else {
							playerImg.src = '../images/playerHasAlreadyVisitedTreasure.png';
				    		td.appendChild(playerImg);
						}
					} else if (tile.playerPositionState === "EnemyPlayerPosition") {
						if (!playerTreasureCollected) {
							playerImg.src = '../images/myTreasureFoundByEnemyBeforeMe.png';
				    		td.appendChild(playerImg);
						} else {
							playerImg.src = '../images/myTreasureFoundByEnemy.png';
				    		td.appendChild(playerImg);
						}
					} else {
						if (!playerHasAlreadyVisitedTreasure) {
							playerImg.src = '../images/bothPlayersOnMyTreasure.png';
				    		td.appendChild(playerImg);
						} else {
							playerImg.src = '../images/bothPlayersIfPlayerHasAlreadyVisitedTreasure.png';
				    		td.appendChild(playerImg);
						}
					}
		        }
		
		        tr.appendChild(td);
		    });
		    mapTable.appendChild(tr);
		});
		addRedLine();
	
	    }).catch(error => {
	        console.error('Map fetch Error:', error);
	    });

		// Fetch opponent data
		if(!opponentTreasureFound){
			fetch(`/game/${gameID}/opponentdata`).then(response => {
				return response.json();
			}).then(data => {
				document.getElementById('opponentUsername').textContent = data.playerUsername;
				document.getElementById('opponentUsername').style.display = 'block';
				if (data && data.collectedTreasure) {
						document.getElementById('opponentTreasureCollected').style.display = 'block';
						document.getElementById('opponentTreasureNotCollected').style.display = 'none';

						opponentTreasureFound = true;
				}
			}).catch(error => {
				if (error instanceof SyntaxError) {
					console.log('No opponent joined');
				} else {
					console.error('Opponent fetch Error:', error);
				}
			});
		}
	
	    // Call the function again after 0.5 seconds
	    setTimeout(updateGameData, 500);
	}
	
	// Start the function
	updateGameData();
	
	document.querySelectorAll("[data-move]").forEach(button => {
	    button.addEventListener("click", function() {
	        const moveDirection = button.getAttribute("data-move");
	        sendMoveRequest(moveDirection);
	    });
	});
	
	function sendMoveRequest(moveDirection) {
	    if (!gameID) {
	        console.error("Game ID not found");
	        return;
	    }
	
	    fetch(`/game/${gameID}/move`, {
	        method: 'POST',
	        headers: {
	            'Content-Type': 'application/x-www-form-urlencoded',
	        },
	        body: `move=${moveDirection}`
	    })
	    .then(response => response.text())
	    .then(result => {
		    console.log(result);
		
		    if (result !== "Move accepted") {
		        const errorMessageDiv = document.getElementById('errorMessage');
		        errorMessageDiv.textContent = 'Check the rules again! ' + result;
		        errorMessageDiv.style.display = 'block';
		    
		        // Hide the error message after 5 seconds
		        setTimeout(() => {
		            errorMessageDiv.style.display = 'none';
		        }, 5000);
		    }
		})
	    .catch(error => {
		    console.error('Error:', error);
		});
	}

    document.getElementById('copyButton').addEventListener('click', function() {
        const gameIdElement = document.querySelector('.copy-container span');
        const gameIdValue = gameIdElement.textContent.replace('Game ID: ', '');
        const textarea = document.createElement('textarea');

        // Set the value of the textarea to the extracted Game ID value
        textarea.value = gameIdValue;

        // Append the textarea to the document (offscreen)
        textarea.style.position = 'absolute';
        textarea.style.left = '-9999px';
        document.body.appendChild(textarea);

        // Focus and select the content of the textarea
        textarea.focus();
        textarea.select();

        // Attempt to copy
        try {
            document.execCommand('copy');
            // Show the notification
            const notification = document.getElementById('notification');
            notification.style.display = 'block';
            setTimeout(function() {
                notification.style.display = 'none';
            }, 2000);  // The notification will be hidden after 2 seconds
        } catch (err) {
            alert('Failed to copy GAME ID');
        }

        // Cleanup - remove the textarea from the document
        document.body.removeChild(textarea);
    });

    document.getElementById('leaveGameButton').addEventListener('click', function() {
        const popup = document.getElementById('leaveGamePopup');
        popup.style.display = 'block';
    });

    document.getElementById('confirmLeave').addEventListener('click', function() {
        const popup = document.getElementById('leaveGamePopup');
        popup.style.display = 'none';
        window.location.href = '/menu';
    });


    document.getElementById('cancelLeave').addEventListener('click', function() {
        const popup = document.getElementById('leaveGamePopup');
        popup.style.display = 'none';
    });



    function endGame(isWinner) {
        // Show the end game container
        document.getElementById('endGameContainer').style.display = 'block';

        // Set the message based on whether the player won or lost
        let message = isWinner ? "You won!" : "You lost!";
        document.getElementById('endGameMessage').innerText = message;

        // Set up click event to return to the menu
        document.getElementById('endGameContainer').addEventListener('click', function() {
            window.location.href = "/menu";
        });
    }

    function checkEndGameState() {
        const stateWon = document.getElementById('stateWon');
        const stateLost = document.getElementById('stateLost');

        if (stateWon.style.display === 'block') {
            endGame(true);
        } else if (stateLost.style.display === 'block') {
            endGame(false);
        }
    }

    // This is the callback function that the observer will run
    // when it notices a change in the targeted elements.
    function mutationCallback(mutationsList, observer) {
        for(let mutation of mutationsList) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                checkEndGameState();
            }
        }
    }

    // Setting up the observer
    const observer = new MutationObserver(mutationCallback);

    // Options for the observer (which mutations to observe)
    const config = { attributes: true, childList: false, subtree: false };

    // Start observing the target nodes for configured mutations
    observer.observe(document.getElementById('stateWon'), config);
    observer.observe(document.getElementById('stateLost'), config);


</script>
</body>
</html>
